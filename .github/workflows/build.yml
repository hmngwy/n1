name: ZMK Build + Bundle

on: [push, pull_request, workflow_dispatch]

jobs:
  build:
    uses: zmkfirmware/zmk/.github/workflows/build-user-config.yml@main

  package-bundles:
    runs-on: ubuntu-latest
    needs: [build]
    strategy:
      fail-fast: false
      matrix:
        layout: [qwerty, colemak, dvorak]
        split:  [duo, trio]

    steps:
      - name: Prepare dirs
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p dl work firmware stage

      - name: Download merged firmware artifact(s)
        uses: actions/download-artifact@v4
        with:
          pattern: firmware*
          path: dl
          merge-multiple: true

      - name: Inspect downloaded payload
        shell: bash
        run: |
          set -euo pipefail
          echo "::group::Downloaded tree"
          ls -lah dl || true
          if command -v tree >/dev/null 2>&1; then tree -a dl || true; fi
          echo "::endgroup::"

      - name: Extract all archives and collect UF2/BINs
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          mkdir -p work firmware

          # 1) Unzip any zips we got
          for z in dl/*.zip dl/**/*.zip; do
            echo "Unzipping: $z"
            unzip -q "$z" -d work
          done

          # 2) Pull *.tar.gz into work/tars (from dl/ or work/)
          mkdir -p work/tars
          find dl work -type f -name '*.tar.gz' -print -exec mv -f {} work/tars/ \; || true

          # 3) Untar everything to work/out
          mkdir -p work/out
          for t in work/tars/*.tar.gz; do
            echo "Untarring: $t"
            tar -xzf "$t" -C work/out || {
              echo "Warning: failed to untar $t (may be empty)"; true;
            }
          done

          # 4) Collect any UF2/BIN from anywhere
          mapfile -t outs < <(find dl work -type f \( -name '*.uf2' -o -name '*.bin' \) )
          if [[ ${#outs[@]} -eq 0 ]]; then
            echo "No UF2/BIN files found after extraction."
            echo "::group::Post-extraction tree"
            if command -v tree >/dev/null 2>&1; then tree -a dl work || true; else ls -lahR dl work || true; fi
            echo "::endgroup::"
            exit 1
          fi

          echo "Collecting ${#outs[@]} firmware file(s) into firmware/:"
          for f in "${outs[@]}"; do
            cp -f "$f" "firmware/$(basename "$f")"
          done

          echo "::group::Firmware dir contents"
          ls -lah firmware
          echo "::endgroup::"

      - name: Compute names for this bundle
        id: names
        shell: bash
        run: |
          set -euo pipefail
          L="${{ matrix.layout }}"
          S="${{ matrix.split }}"
          echo "reset=_reset" >> "$GITHUB_OUTPUT"
          echo "right=any_right_peripheral" >> "$GITHUB_OUTPUT"
          if [[ "$S" == "duo" ]]; then
            echo "central=${L}_duo_split_left" >> "$GITHUB_OUTPUT"
            echo "left=" >> "$GITHUB_OUTPUT"
          else
            echo "central=${L}_trio_split_central" >> "$GITHUB_OUTPUT"
            echo "left=${L}_trio_split_left"     >> "$GITHUB_OUTPUT"
          fi

      - name: Resolve extensions (.uf2 preferred; fall back to .bin)
        id: ext
        shell: bash
        run: |
          set -euo pipefail
          choose_ext () {
            local base="$1"
            if [[ -f "firmware/${base}.uf2" ]]; then
              echo "uf2"
            elif [[ -f "firmware/${base}.bin" ]]; then
              echo "bin"
            else
              echo ""
            fi
          }

          c_ext="$(choose_ext "${{ steps.names.outputs.central }}")"
          r_ext="$(choose_ext "${{ steps.names.outputs.right }}")"
          x_ext="$(choose_ext "${{ steps.names.outputs.reset }}")"
          l_ext=""
          if [[ -n "${{ steps.names.outputs.left }}" ]]; then
            l_ext="$(choose_ext "${{ steps.names.outputs.left }}")"
          fi

          echo "central_ext=$c_ext" >> "$GITHUB_OUTPUT"
          echo "right_ext=$r_ext"   >> "$GITHUB_OUTPUT"
          echo "reset_ext=$x_ext"   >> "$GITHUB_OUTPUT"
          echo "left_ext=$l_ext"    >> "$GITHUB_OUTPUT"

      - name: Verify required firmware files exist
        shell: bash
        run: |
          set -euo pipefail
          miss=0
          check () {
            local base="$1" ext="$2"
            if [[ -z "$ext" ]] || [[ ! -f "firmware/${base}.${ext}" ]]; then
              echo "Missing firmware/${base}.${ext:-<none>}"
              miss=1
            fi
          }
          check "${{ steps.names.outputs.central }}" "${{ steps.ext.outputs.central_ext }}"
          check "${{ steps.names.outputs.right }}"   "${{ steps.ext.outputs.right_ext }}"
          check "${{ steps.names.outputs.reset }}"   "${{ steps.ext.outputs.reset_ext }}"
          if [[ -n "${{ steps.names.outputs.left }}" ]]; then
            check "${{ steps.names.outputs.left }}" "${{ steps.ext.outputs.left_ext }}"
          fi
          [[ $miss -eq 0 ]]

      - name: Stage files with normalized names (root-level)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf stage && mkdir -p stage
          L="${{ matrix.layout }}"
          S="${{ matrix.split }}"
          C_EXT="${{ steps.ext.outputs.central_ext }}"
          R_EXT="${{ steps.ext.outputs.right_ext }}"
          X_EXT="${{ steps.ext.outputs.reset_ext }}"
          L_EXT="${{ steps.ext.outputs.left_ext }}"

          # Central (duo=left; trio=central)
          cp "firmware/${{ steps.names.outputs.central }}.${C_EXT}" \
             "stage/${{ steps.names.outputs.central }}.${C_EXT}"

          # Left peripheral only for trio
          if [[ -n "${{ steps.names.outputs.left }}" ]]; then
            cp "firmware/${{ steps.names.outputs.left }}.${L_EXT}" \
               "stage/${{ steps.names.outputs.left }}.${L_EXT}"
          fi

          # Right peripheral: rename to match the requested pattern
          #   <layout>_<split>_split_right.<ext>
          cp "firmware/${{ steps.names.outputs.right }}.${R_EXT}" \
             "stage/${L}_${S}_split_right.${R_EXT}"

          # Reset (keep as _reset.<ext>)
          cp "firmware/${{ steps.names.outputs.reset }}.${X_EXT}" \
             "stage/_reset.${X_EXT}"

          echo "::group::Staged files (will be at root of downloaded zip)"
          ls -lah stage
          echo "::endgroup::"

      # IMPORTANT: upload the files themselves (not our own zip)
      # GitHub will create a single zip per artifact WITH THESE FILES AT ROOT.
      - name: Upload bundle (files at root)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.layout }}_${{ matrix.split }}
          path: stage/*
          if-no-files-found: error

