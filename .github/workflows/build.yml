name: ZMK Build + Publish

on:
  # Build on every commit and PR
  push:
    branches: ['**']
  pull_request:
  # Manual "publish" run for releases + README update
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag (e.g., v2025.08.21)"
        required: true
        default: "v0.0.0"
      title:
        description: "Release title"
        required: false
        default: "Firmware"
      prerelease:
        description: "Mark as prerelease?"
        required: true
        default: "false"
        type: choice
        options: ["false", "true"]

permissions:
  contents: write   # needed for releases + README commit

jobs:
  # 0) Determine TAG
  determine-tag:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.set-tag.outputs.TAG }}
      prerelease: ${{ steps.set-tag.outputs.PRERELEASE }}
      title: ${{ steps.set-tag.outputs.TITLE }}
    steps:
      - name: Compute TAG
        id: set-tag
        shell: bash
        env:
          EV: ${{ github.event_name }}
          IN_TAG: ${{ inputs.tag }}
          IN_TITLE: ${{ inputs.title }}
          IN_PRE: ${{ inputs.prerelease }}
          SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          if [[ "$EV" == "workflow_dispatch" ]]; then
            TAG="${IN_TAG}"                 # manual tag, e.g. v2025.08.21
            TITLE="${IN_TITLE:-Firmware}"
            PRE="${IN_PRE:-false}"
          else
            SHORT="$(echo "$SHA" | cut -c1-7)"
            TAG="${SHORT}"                  # ci run => 7-char commit hash
            TITLE="CI Firmware ${SHORT}"
            PRE="true"
          fi
          echo "TAG=$TAG"        | tee -a "$GITHUB_OUTPUT"
          echo "TITLE=$TITLE"    | tee -a "$GITHUB_OUTPUT"
          echo "PRERELEASE=$PRE" | tee -a "$GITHUB_OUTPUT"

  # 1) Build using ZMK's official workflow
  build:
    uses: zmkfirmware/zmk/.github/workflows/build-user-config.yml@main
    needs: [determine-tag]

  # 2) Package: collect outputs, rename with tag, zip per layout/split
  package:
    runs-on: ubuntu-latest
    needs: [build, determine-tag]
    strategy:
      fail-fast: false
      matrix:
        layout: [qwerty, colemak, dvorak]
        split:  [duo, trio]

    steps:
      - name: Prep
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p dl work firmware stage dist

      - name: Download merged firmware artifact(s)
        uses: actions/download-artifact@v4
        with:
          pattern: firmware*
          path: dl
          merge-multiple: true

      - name: Extract and collect UF2/BINs
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          mkdir -p work firmware
          # Unzip anything we got
          for z in dl/*.zip dl/**/*.zip; do unzip -q "$z" -d work || true; done
          # Pull + untar nested tarballs
          mkdir -p work/tars work/out
          find dl work -type f -name '*.tar.gz' -print -exec mv -f {} work/tars/ \; || true
          for t in work/tars/*.tar.gz; do tar -xzf "$t" -C work/out || true; done
          # Collect UF2/BINs
          mapfile -t outs < <(find dl work -type f \( -name '*.uf2' -o -name '*.bin' \))
          [[ ${#outs[@]} -gt 0 ]] || { echo "No UF2/BIN found"; exit 1; }
          for f in "${outs[@]}"; do cp -f "$f" "firmware/$(basename "$f")"; done
          echo "Collected firmware files:"; ls -lah firmware || true

      - name: Compute artifact base names
        id: names
        shell: bash
        run: |
          set -euo pipefail
          L="${{ matrix.layout }}"
          S="${{ matrix.split }}"
          echo "reset=_reset" >> "$GITHUB_OUTPUT"
          echo "right=any_right_peripheral" >> "$GITHUB_OUTPUT"
          if [[ "$S" == "duo" ]]; then
            echo "central=${L}_duo_split_left" >> "$GITHUB_OUTPUT"
            echo "left=" >> "$GITHUB_OUTPUT"
          else
            echo "central=${L}_trio_split_central" >> "$GITHUB_OUTPUT"
            echo "left=${L}_trio_split_left"     >> "$GITHUB_OUTPUT"
          fi

      - name: Resolve extensions (.uf2 preferred; .bin fallback)
        id: ext
        shell: bash
        run: |
          set -euo pipefail
          ext () { [[ -f "firmware/$1.uf2" ]] && echo uf2 || { [[ -f "firmware/$1.bin" ]] && echo bin || echo ""; }; }
          echo "central_ext=$(ext '${{ steps.names.outputs.central }}')" >> "$GITHUB_OUTPUT"
          echo "right_ext=$(ext   '${{ steps.names.outputs.right }}')"   >> "$GITHUB_OUTPUT"
          echo "reset_ext=$(ext   '${{ steps.names.outputs.reset }}')"   >> "$GITHUB_OUTPUT"
          if [[ -n "${{ steps.names.outputs.left }}" ]]; then
            echo "left_ext=$(ext '${{ steps.names.outputs.left }}')"     >> "$GITHUB_OUTPUT"
          else
            echo "left_ext=" >> "$GITHUB_OUTPUT"
          fi

      - name: Verify expected files exist
        shell: bash
        run: |
          set -euo pipefail
          miss=0
          check () { local base="$1" ext="$2"; [[ -n "$ext" && -f "firmware/${base}.${ext}" ]] || { echo "Missing ${base}.${ext:-<none>}"; miss=1; }; }
          check "${{ steps.names.outputs.central }}" "${{ steps.ext.outputs.central_ext }}"
          check "${{ steps.names.outputs.right }}"   "${{ steps.ext.outputs.right_ext }}"
          check "${{ steps.names.outputs.reset }}"   "${{ steps.ext.outputs.reset_ext }}"
          if [[ -n "${{ steps.names.outputs.left }}" ]]; then
            check "${{ steps.names.outputs.left }}" "${{ steps.ext.outputs.left_ext }}"
          fi
          [[ $miss -eq 0 ]]

      - name: Stage & zip per matrix (flat; hyphenated tag)
        shell: bash
        env:
          TAG: ${{ needs.determine-tag.outputs.tag }}
        run: |
          set -euo pipefail
          L="${{ matrix.layout }}"; S="${{ matrix.split }}"
          C_EXT="${{ steps.ext.outputs.central_ext }}"
          R_EXT="${{ steps.ext.outputs.right_ext }}"
          X_EXT="${{ steps.ext.outputs.reset_ext }}"
          L_EXT="${{ steps.ext.outputs.left_ext }}"
          rm -rf stage && mkdir -p stage dist

          # Central
          cp "firmware/${{ steps.names.outputs.central }}.${C_EXT}" \
             "stage/${{ steps.names.outputs.central }}-${TAG}.${C_EXT}"

          # Trio left (if any)
          if [[ -n "${{ steps.names.outputs.left }}" ]]; then
            cp "firmware/${{ steps.names.outputs.left }}.${L_EXT}" \
               "stage/${{ steps.names.outputs.left }}-${TAG}.${L_EXT}"
          fi

          # Right peripheral
          cp "firmware/${{ steps.names.outputs.right }}.${R_EXT}" \
             "stage/${L}_${S}_split_right-${TAG}.${R_EXT}"

          # Reset
          cp "firmware/${{ steps.names.outputs.reset }}.${X_EXT}" \
             "stage/_reset-${TAG}.${X_EXT}"

          echo "Staged files:"
          ls -lah stage

          OUT="dist/${L}_${S}-${TAG}.zip"
          zip -q -j "$OUT" stage/*   # -j puts UF2s at root
          echo "Created $OUT"
          unzip -l "$OUT"

      - name: Upload CI artifact (clean name)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.layout }}_${{ matrix.split }}   # e.g. qwerty_duo
          path: dist/*.zip

  # 3) Publish only for manual runs
  publish:
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    needs: [package, determine-tag]

    steps:
      - uses: actions/checkout@v4

      - name: Download packaged zips
        uses: actions/download-artifact@v4
        with:
          pattern: '*_*'
          path: dist
          merge-multiple: true

      - name: Create or update release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.determine-tag.outputs.tag }}
          TITLE: ${{ needs.determine-tag.outputs.title }}
          PRERELEASE: ${{ needs.determine-tag.outputs.prerelease }}
        shell: bash
        run: |
          set -euo pipefail
          if ! gh release view "$TAG" >/dev/null 2>&1; then
            gh release create "$TAG" --title "${TITLE} ${TAG}" \
              --notes "Automated firmware build for ${TAG}" \
              $([[ "$PRERELEASE" == "true" ]] && echo "--prerelease")
          fi
          gh release upload "$TAG" dist/*.zip --clobber

      - name: Regenerate README firmware links
        env:
          TAG: ${{ needs.determine-tag.outputs.tag }}
          REPO: ${{ github.repository }}
        shell: bash
        run: |
          set -euo pipefail

          # 1) Generate the replacement block to a temp file (includes markers)
          NEWFILE="$(mktemp)"
          {
            echo "## Downloads"
            echo
            echo "<!-- FIRMWARE-LINKS:START - Do not edit below, this section is managed by CI -->"
            echo
            gen_group () {
              local L="$1"
              local LUP="$(tr '[:lower:]' '[:upper:]' <<< ${L:0:1})${L:1}"
              echo "- ${LUP}"
              for S in duo trio; do
                local FILE="${L}_${S}-${TAG}.zip"
                if [[ -f "dist/$FILE" ]]; then
                  echo "  - [${S^}](https://github.com/${REPO}/releases/download/${TAG}/${FILE})"
                fi
              done
            }
            gen_group qwerty
            gen_group colemak
            gen_group dvorak
            echo
            echo "<!-- FIRMWARE-LINKS:END -->"
          } > "$NEWFILE"

          # 2) Splice it into README.md between the markers safely
          awk -v blockfile="$NEWFILE" '
            BEGIN {
              # Read the entire replacement block from file
              while ((getline line < blockfile) > 0) {
                block = block line "\n"
              }
              close(blockfile)
            }
            {
              if ($0 ~ /<!-- FIRMWARE-LINKS:START/) {
                print block
                inblock = 1
                next
              }
              if ($0 ~ /<!-- FIRMWARE-LINKS:END -->/) {
                inblock = 0
                next
              }
              if (!inblock) print
            }
          ' README.md > README.tmp

          mv README.tmp README.md

