name: ZMK Build + Bundle

on: [push, pull_request, workflow_dispatch]

jobs:
  build:
    uses: zmkfirmware/zmk/.github/workflows/build-user-config.yml@main

  package-bundles:
    runs-on: ubuntu-latest
    needs: [build]
    strategy:
      fail-fast: false
      matrix:
        layout: [qwerty, colemak, dvorak]
        split:  [duo, trio]

    steps:
      - name: Prepare dirs
        run: |
          set -euo pipefail
          mkdir -p dl firmware unzip bundle

      # Download the single merged artifact produced by ZMK.
      # Use a pattern in case the name has a suffix.
      - name: Download merged firmware artifact
        uses: actions/download-artifact@v4
        with:
          pattern: firmware*
          path: dl
          merge-multiple: true

      - name: Unpack merged artifact (zip â†’ tars)
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          # The ZMK workflow uploads a zip containing *.tar.gz, one per artifact-name
          for z in dl/*.zip; do
            unzip -q "$z" -d unzip
          done
          # Move *.tar.gz into a flat folder for easy lookup
          mkdir -p firmware
          mv unzip/*.tar.gz firmware/ || true
          echo "Found tars:"
          ls -lah firmware || true

      - name: Compute names for this bundle
        id: names
        shell: bash
        run: |
          set -euo pipefail
          L="${{ matrix.layout }}"
          S="${{ matrix.split }}"
          echo "reset=_reset" >> "$GITHUB_OUTPUT"
          echo "right=any_right_peripheral" >> "$GITHUB_OUTPUT"
          if [[ "$S" == "duo" ]]; then
            echo "central=${L}_duo_split_left" >> "$GITHUB_OUTPUT"
            echo "left=" >> "$GITHUB_OUTPUT"
          else
            echo "central=${L}_trio_split_central" >> "$GITHUB_OUTPUT"
            echo "left=${L}_trio_split_left"     >> "$GITHUB_OUTPUT"
          fi

      - name: Verify required tars exist
        shell: bash
        run: |
          set -euo pipefail
          miss=0
          need=( "${{ steps.names.outputs.central }}" "${{ steps.names.outputs.right }}" "${{ steps.names.outputs.reset }}" )
          if [[ -n "${{ steps.names.outputs.left }}" ]]; then
            need+=( "${{ steps.names.outputs.left }}" )
          fi
          for n in "${need[@]}"; do
            if [[ ! -f "firmware/${n}.tar.gz" ]]; then
              echo "Missing firmware/${n}.tar.gz"
              miss=1
            fi
          done
          if [[ $miss -ne 0 ]]; then
            echo "One or more required artifacts are missing. Check your build matrix artifact-name values."
            exit 1
          fi

      - name: Build combined bundle
        shell: bash
        run: |
          set -euo pipefail
          rm -rf bundle && mkdir -p bundle/central bundle/right bundle/reset
          [[ -n "${{ steps.names.outputs.left }}" ]] && mkdir -p bundle/left

          tar -xzf "firmware/${{ steps.names.outputs.central }}.tar.gz" -C bundle/central
          if [[ -n "${{ steps.names.outputs.left }}" ]]; then
            tar -xzf "firmware/${{ steps.names.outputs.left }}.tar.gz"    -C bundle/left
          fi
          tar -xzf "firmware/${{ steps.names.outputs.right }}.tar.gz"   -C bundle/right
          tar -xzf "firmware/${{ steps.names.outputs.reset }}.tar.gz"   -C bundle/reset

          # Write a tiny README without heredocs (avoids EOF quoting issues)
          {
            echo "Bundle: ${{ matrix.layout }} ${{ matrix.split }}"
            echo "Contents:"
            echo "- central/: firmware for central controller"
            if [[ -n "${{ steps.names.outputs.left }}" ]]; then
              echo "- left/:    (trio only) left peripheral firmware"
            fi
            echo "- right/:   shared right peripheral firmware"
            echo "- reset/:   settings_reset UF2"
          } > bundle/README.txt

          OUT="${{ matrix.layout }}_${{ matrix.split }}.tar.gz"
          tar -czf "$OUT" -C bundle .
          echo "OUT=$OUT" >> "$GITHUB_ENV"
          echo "Wrote $OUT"

      - name: Upload bundle
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.layout }}_${{ matrix.split }}
          path: ${{ env.OUT }}

